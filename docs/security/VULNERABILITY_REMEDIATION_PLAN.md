# VULNERABILITY REMEDIATION PLAN
## HRMS Multi-Tenant Application - Security Hardening Roadmap

**Document Version:** 1.0
**Last Updated:** 2025-11-17
**Status:** ACTIVE
**Owner:** Security Team
**Priority:** HIGH

---

## EXECUTIVE SUMMARY

This remediation plan addresses **3 High-priority**, **8 Medium-priority**, and **5 Low-priority** security findings identified in the comprehensive security audit. The plan is structured in 3 phases over 6 weeks with clear ownership, timelines, and acceptance criteria.

**Total Effort:** ~115 hours (~3 weeks for 1 developer)
**Business Impact:** Minimal (mostly backend/infrastructure changes)
**Downtime Required:** None (rolling deployments)

---

## REMEDIATION PHASES

### Phase 1: Critical & High Priority (Weeks 1-2) - 14 hours

**Objective:** Address immediate security risks
**Target Completion:** End of Week 2
**Risk Reduction:** 70% of identified risks

---

### Phase 2: Medium Priority (Weeks 3-4) - 28 hours

**Objective:** Harden security controls
**Target Completion:** End of Week 4
**Risk Reduction:** 25% of identified risks

---

### Phase 3: Low Priority (Weeks 5-6) - 14 hours

**Objective:** Implement security best practices
**Target Completion:** End of Week 6
**Risk Reduction:** 5% of identified risks

---

## PHASE 1: HIGH PRIORITY FIXES

### H-001: Implement HTTP Security Headers

**Finding ID:** H-001
**Severity:** HIGH
**CVSS Score:** 6.5
**Effort:** 4 hours
**Owner:** Backend Team
**Status:** Not Started

---

#### Problem Description

Application does not implement critical HTTP security headers, exposing it to:
- Clickjacking attacks (missing X-Frame-Options)
- MIME type sniffing (missing X-Content-Type-Options)
- XSS attacks (missing Content-Security-Policy)
- SSL downgrade attacks (missing Strict-Transport-Security)

**Current State:**
- No security headers middleware
- No CSP meta tags in index.html
- No HSTS enforcement

**Risk Impact:**
- Clickjacking: Attacker can embed application in iframe for credential theft
- MIME sniffing: Browser could execute malicious content
- XSS: Increased attack surface without CSP
- SSL downgrade: MITM attacks possible

---

#### Remediation Steps

**Step 1: Create Security Headers Middleware (2 hours)**

Create `/workspaces/HRAPP/src/HRMS.API/Middleware/SecurityHeadersMiddleware.cs`:

```csharp
using Microsoft.AspNetCore.Http;
using System.Threading.Tasks;

namespace HRMS.API.Middleware
{
    /// <summary>
    /// Adds security headers to all HTTP responses
    /// Implements OWASP security header recommendations
    /// </summary>
    public class SecurityHeadersMiddleware
    {
        private readonly RequestDelegate _next;

        public SecurityHeadersMiddleware(RequestDelegate next)
        {
            _next = next;
        }

        public async Task InvokeAsync(HttpContext context)
        {
            // Remove server header (information disclosure)
            context.Response.Headers.Remove("Server");
            context.Response.Headers.Remove("X-Powered-By");

            // Content Security Policy (CSP)
            // Allows scripts/styles from same origin and specific CDNs
            context.Response.Headers.Add("Content-Security-Policy",
                "default-src 'self'; " +
                "script-src 'self' 'unsafe-inline' 'unsafe-eval'; " +  // Note: Remove unsafe-* in Phase 2
                "style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; " +
                "font-src 'self' https://fonts.gstatic.com; " +
                "img-src 'self' data: https:; " +
                "connect-src 'self' https://repulsive-toad-7vjj6xv99745hrvj-5090.app.github.dev wss://repulsive-toad-7vjj6xv99745hrvj-5090.app.github.dev; " +
                "frame-ancestors 'none'; " +
                "base-uri 'self'; " +
                "form-action 'self'; " +
                "upgrade-insecure-requests;");

            // Prevent clickjacking
            context.Response.Headers.Add("X-Frame-Options", "DENY");

            // Prevent MIME type sniffing
            context.Response.Headers.Add("X-Content-Type-Options", "nosniff");

            // Enable browser XSS protection (legacy browsers)
            context.Response.Headers.Add("X-XSS-Protection", "1; mode=block");

            // Strict Transport Security (HSTS)
            // Force HTTPS for 1 year, including subdomains
            if (context.Request.IsHttps)
            {
                context.Response.Headers.Add("Strict-Transport-Security",
                    "max-age=31536000; includeSubDomains; preload");
            }

            // Referrer Policy (privacy)
            context.Response.Headers.Add("Referrer-Policy",
                "strict-origin-when-cross-origin");

            // Permissions Policy (disable unnecessary browser features)
            context.Response.Headers.Add("Permissions-Policy",
                "geolocation=(), microphone=(), camera=(), payment=(), usb=()");

            await _next(context);
        }
    }

    // Extension method for easy registration
    public static class SecurityHeadersMiddlewareExtensions
    {
        public static IApplicationBuilder UseSecurityHeaders(
            this IApplicationBuilder builder)
        {
            return builder.UseMiddleware<SecurityHeadersMiddleware>();
        }
    }
}
```

**Step 2: Register Middleware in Program.cs (1 hour)**

Update `/workspaces/HRAPP/src/HRMS.API/Program.cs`:

```csharp
// Add after app.UseHttpsRedirection(); (line ~930)
app.UseSecurityHeaders();  // üëà ADD THIS LINE

Log.Information("Security headers middleware enabled: CSP, HSTS, X-Frame-Options, etc.");
```

**Step 3: Test Security Headers (1 hour)**

```bash
# Test locally
curl -I http://localhost:5090/health

# Expected headers:
# Content-Security-Policy: default-src 'self'; ...
# X-Frame-Options: DENY
# X-Content-Type-Options: nosniff
# Strict-Transport-Security: max-age=31536000; includeSubDomains; preload
# Referrer-Policy: strict-origin-when-cross-origin
# Permissions-Policy: geolocation=(), microphone=(), camera=()
```

**Security Scanner Validation:**
```bash
# Use Security Headers scanner
curl -s https://securityheaders.com/?q=https://your-domain.com&followRedirects=on

# Expected Grade: A or A+
```

---

#### Acceptance Criteria

- [ ] SecurityHeadersMiddleware created
- [ ] Middleware registered in Program.cs
- [ ] All security headers present in HTTP responses
- [ ] Security Headers score: A or A+
- [ ] No console errors in frontend
- [ ] All pages load correctly
- [ ] SignalR connections work (CSP allows wss://)
- [ ] External fonts load (CSP allows fonts.googleapis.com)

---

#### Rollback Plan

If CSP breaks functionality:

1. Comment out CSP header in middleware
2. Keep other security headers active
3. Debug CSP violations in browser console
4. Adjust CSP policy and redeploy

```csharp
// Temporarily disable CSP if issues occur
// context.Response.Headers.Add("Content-Security-Policy", ...);
context.Response.Headers.Add("Content-Security-Policy-Report-Only", ...);  // Monitor mode
```

---

#### Testing Checklist

- [ ] Login page loads
- [ ] Dashboard loads
- [ ] SignalR real-time updates work
- [ ] Google Fonts load
- [ ] No console CSP violations (or only expected ones)
- [ ] Browser security headers scan passes
- [ ] Mobile app works (if applicable)

---

### H-002: Remove Refresh Token from localStorage

**Finding ID:** H-002
**Severity:** HIGH
**CVSS Score:** 6.0
**Effort:** 8 hours
**Owner:** Frontend Team
**Status:** Not Started

---

#### Problem Description

Long-lived refresh tokens (7 days) stored in browser localStorage are vulnerable to XSS attacks. If an attacker finds an XSS vulnerability, they can:
1. Steal refresh token from localStorage
2. Maintain persistent access for 7 days
3. Continue refreshing access tokens

**Current State:**
```typescript
// VULNERABLE CODE
// /workspaces/HRAPP/hrms-frontend/src/app/core/services/auth.service.ts:490
localStorage.setItem('refresh_token', response.refreshToken);
```

**Risk Impact:**
- XSS attack ‚Üí Steal refresh token ‚Üí Long-term account access
- Even after fixing XSS, attacker retains access via stolen token

---

#### Remediation Steps

**Step 1: Remove localStorage Storage (2 hours)**

Update `/workspaces/HRAPP/hrms-frontend/src/app/core/services/auth.service.ts`:

```typescript
// BEFORE (line 489-491):
private setAuthState(response: LoginResponse): void {
  localStorage.setItem('access_token', response.token);
  localStorage.setItem('refresh_token', response.refreshToken);  // ‚ùå REMOVE THIS LINE
  localStorage.setItem('user', JSON.stringify(response.user));
  // ...
}

// AFTER:
private setAuthState(response: LoginResponse): void {
  localStorage.setItem('access_token', response.token);
  // ‚úÖ Refresh token now ONLY in HttpOnly cookie (backend handles this)
  localStorage.setItem('user', JSON.stringify(response.user));

  // Save user role for post-logout redirect
  this.saveLastUserRole(response.user.role);

  this.tokenSignal.set(response.token);
  this.userSignal.set(response.user);
}
```

**Step 2: Remove from clearAuthState (1 hour)**

```typescript
// BEFORE (line 510-512):
private clearAuthState(): void {
  localStorage.removeItem('access_token');
  localStorage.removeItem('refresh_token');  // ‚ùå REMOVE THIS LINE
  localStorage.removeItem('user');
  // ...
}

// AFTER:
private clearAuthState(): void {
  localStorage.removeItem('access_token');
  // ‚úÖ Refresh token only in HttpOnly cookie (cleared by backend)
  localStorage.removeItem('user');

  this.tokenSignal.set(null);
  this.userSignal.set(null);
}
```

**Step 3: Verify Backend HttpOnly Cookie (2 hours)**

Ensure backend sets HttpOnly cookie correctly:

```csharp
// Backend should already have this - VERIFY
// /workspaces/HRAPP/src/HRMS.Infrastructure/Services/AuthService.cs

Response.Cookies.Append("refresh_token", refreshToken, new CookieOptions
{
    HttpOnly = true,      // ‚úÖ NOT accessible via JavaScript
    Secure = true,        // ‚úÖ HTTPS only
    SameSite = SameSiteMode.Strict,  // ‚úÖ CSRF protection
    Expires = DateTimeOffset.UtcNow.AddDays(7),
    IsEssential = true
});
```

**Step 4: Test Token Refresh Flow (2 hours)**

```typescript
// Test that refresh still works without localStorage
// Frontend should send HttpOnly cookie automatically

// authInterceptor automatically sends cookie:
return this.http.post<any>(
  endpoint,
  {},
  { withCredentials: true }  // ‚úÖ Sends HttpOnly cookie
)
```

**Step 5: Update Documentation (1 hour)**

Update code comments to reflect new security model:

```typescript
/**
 * SECURITY MODEL:
 * - Access Token: Short-lived (15 min), stored in localStorage
 * - Refresh Token: Long-lived (7 days), stored in HttpOnly cookie
 *
 * WHY THIS IS SECURE:
 * - XSS attacks can steal access token (15 min access)
 * - XSS attacks CANNOT steal refresh token (HttpOnly cookie)
 * - After 15 minutes, attacker loses access
 *
 * TRADE-OFFS:
 * - localStorage XSS risk: Access token only (15 min window)
 * - HttpOnly cookie CSRF risk: Mitigated by SameSite=Strict
 */
```

---

#### Acceptance Criteria

- [ ] `localStorage.setItem('refresh_token', ...)` removed
- [ ] `localStorage.removeItem('refresh_token')` removed
- [ ] Backend sets HttpOnly cookie for refresh token
- [ ] Token refresh flow works (401 ‚Üí refresh ‚Üí retry)
- [ ] Logout clears HttpOnly cookie (backend)
- [ ] No refresh token in browser dev tools ‚Üí localStorage
- [ ] Refresh token visible in browser dev tools ‚Üí Cookies (HttpOnly)
- [ ] Cross-tab logout still works

---

#### Rollback Plan

If refresh flow breaks:

1. Temporarily revert localStorage storage
2. Debug HttpOnly cookie issue
3. Verify `withCredentials: true` in all refresh requests
4. Check CORS settings allow credentials

```typescript
// EMERGENCY ROLLBACK (if needed):
// Uncomment this line temporarily:
// localStorage.setItem('refresh_token', response.refreshToken);
```

---

#### Testing Checklist

- [ ] Login succeeds
- [ ] Token refresh works after 401
- [ ] Logout clears cookie
- [ ] Cross-tab logout works
- [ ] Mobile app works (if applicable)
- [ ] No errors in console
- [ ] Cookie visible in DevTools ‚Üí Application ‚Üí Cookies
- [ ] Cookie has HttpOnly flag
- [ ] Cookie has Secure flag
- [ ] Cookie has SameSite=Strict

---

### H-003: Rotate SuperAdmin Secret Path

**Finding ID:** H-003
**Severity:** MEDIUM-HIGH
**CVSS Score:** 5.5
**Effort:** 2 hours
**Owner:** DevOps Team
**Status:** Not Started

---

#### Problem Description

SuperAdmin login URL uses a secret path (UUID) hardcoded in frontend environment files:
- Frontend: `/api/auth/system-732c44d0-d59b-494c-9fc0-bf1d65add4e5`
- Visible in browser dev tools and source code

**Current State:**
```typescript
// /workspaces/HRAPP/hrms-frontend/src/environments/environment.ts:8
superAdminSecretPath: '732c44d0-d59b-494c-9fc0-bf1d65add4e5'
```

**Risk Impact:**
- If source code leaks, secret URL is compromised
- Same secret used in dev/staging/production (bad practice)
- No rotation policy in place

**Compensating Controls (Already Implemented):**
- ‚úÖ Rate limiting (5 attempts/15min)
- ‚úÖ MFA/TOTP required after login
- ‚úÖ Audit logging of failed attempts

---

#### Remediation Steps

**Step 1: Generate New Secrets (30 minutes)**

```bash
# Generate different UUIDs for each environment
uuidgen  # Dev:  e4a8c7b2-9d3f-4e21-a6c5-8f1b2e3d4c5a
uuidgen  # Stg:  f7b9d8c3-0e4a-5f32-b7d6-9g2c3f4e5d6b
uuidgen  # Prod: a1b2c3d4-5e6f-7g8h-9i0j-1k2l3m4n5o6p
```

**Step 2: Update Backend Configuration (30 minutes)**

Update `/workspaces/HRAPP/src/HRMS.API/appsettings.json`:

```json
{
  "Auth": {
    "SuperAdminSecretPath": "a1b2c3d4-5e6f-7g8h-9i0j-1k2l3m4n5o6p"  // üëà NEW SECRET
  }
}
```

**For Production:**
```bash
# Set via environment variable (do NOT commit to git)
export AUTH__SUPERADMINSECRETPATH="a1b2c3d4-5e6f-7g8h-9i0j-1k2l3m4n5o6p"

# OR use Google Secret Manager
gcloud secrets create SUPERADMIN_SECRET_PATH \
  --data-file=- <<< "a1b2c3d4-5e6f-7g8h-9i0j-1k2l3m4n5o6p"
```

**Step 3: Update Frontend Environment Files (30 minutes)**

Update `/workspaces/HRAPP/hrms-frontend/src/environments/environment.ts`:

```typescript
export const environment = {
  production: false,
  apiUrl: 'https://...',
  superAdminSecretPath: 'e4a8c7b2-9d3f-4e21-a6c5-8f1b2e3d4c5a',  // üëà NEW DEV SECRET
  // ...
};
```

Update `/workspaces/HRAPP/hrms-frontend/src/environments/environment.prod.ts`:

```typescript
export const environment = {
  production: true,
  apiUrl: 'https://...',
  superAdminSecretPath: 'a1b2c3d4-5e6f-7g8h-9i0j-1k2l3m4n5o6p',  // üëà NEW PROD SECRET
  // ...
};
```

**Step 4: Document Secret Rotation Policy (30 minutes)**

Create `/docs/SECRET_ROTATION_POLICY.md`:

```markdown
# SuperAdmin Secret Path Rotation Policy

## Rotation Schedule
- Quarterly (every 3 months)
- Immediately upon suspected compromise
- After employee termination with access

## Rotation Process
1. Generate new UUID: `uuidgen`
2. Update backend config (environment variable)
3. Update frontend environment files
4. Deploy backend first
5. Deploy frontend
6. Notify SuperAdmin users of new URL
7. Document rotation in security log

## Current Secrets
- Production: [REDACTED] (last rotated: 2025-11-17)
- Staging: [REDACTED] (last rotated: 2025-11-17)
- Development: [REDACTED] (last rotated: 2025-11-17)

## Access
Only the following roles can access secrets:
- CTO
- Security Team Lead
- DevOps Lead
```

---

#### Acceptance Criteria

- [ ] New UUIDs generated for each environment
- [ ] Backend configuration updated
- [ ] Frontend environment files updated
- [ ] Old secret no longer works
- [ ] New secret works for SuperAdmin login
- [ ] Rotation policy documented
- [ ] Secrets stored in password manager
- [ ] Production secret in Google Secret Manager
- [ ] Calendar reminder for quarterly rotation

---

#### Rollback Plan

If SuperAdmin login breaks:

1. Revert backend to old secret
2. Verify frontend-backend secret match
3. Redeploy

```bash
# Emergency rollback
export AUTH__SUPERADMINSECRETPATH="732c44d0-d59b-494c-9fc0-bf1d65add4e5"
```

---

## PHASE 2: MEDIUM PRIORITY FIXES

### M-001: Review File Upload Security

**Finding ID:** M-001
**Severity:** MEDIUM
**Effort:** 4 hours
**Owner:** Backend Team

---

#### Remediation Steps

**Step 1: Review EmployeeDraftsController (2 hours)**

Check for file upload vulnerabilities:

```csharp
// /workspaces/HRAPP/src/HRMS.API/Controllers/EmployeeDraftsController.cs

// Verify:
[RequestSizeLimit(10_485_760)]  // 10MB limit
[RequestFormLimits(MultipartBodyLengthLimit = 10_485_760)]
public async Task<IActionResult> SaveDraft([FromBody] SaveEmployeeDraftRequest request)
{
    // 1. Validate file type (whitelist)
    var allowedExtensions = new[] { ".pdf", ".docx", ".xlsx", ".jpg", ".png" };

    // 2. Validate file size
    if (file.Length > 10 * 1024 * 1024) // 10MB
        return BadRequest("File too large");

    // 3. Validate MIME type
    var allowedMimeTypes = new[] { "application/pdf", "image/jpeg", "image/png" };

    // 4. Sanitize filename
    var sanitizedFilename = Path.GetFileName(file.FileName);

    // 5. Scan for malware (if applicable)
    // await _antivirusService.ScanAsync(file);

    // 6. Store with random name (prevent path traversal)
    var storedFilename = $"{Guid.NewGuid()}{Path.GetExtension(sanitizedFilename)}";
}
```

**Step 2: Add File Validation Middleware (2 hours)**

Create file validation helper:

```csharp
public static class FileValidationHelper
{
    private static readonly Dictionary<string, List<byte[]>> FileSignatures = new()
    {
        { ".pdf", new List<byte[]> { new byte[] { 0x25, 0x50, 0x44, 0x46 } } },  // %PDF
        { ".jpg", new List<byte[]> { new byte[] { 0xFF, 0xD8, 0xFF } } },
        { ".png", new List<byte[]> { new byte[] { 0x89, 0x50, 0x4E, 0x47 } } }
    };

    public static bool IsValidFileType(IFormFile file, string[] allowedExtensions)
    {
        var extension = Path.GetExtension(file.FileName).ToLowerInvariant();
        if (!allowedExtensions.Contains(extension))
            return false;

        // Verify file signature (magic bytes)
        using var stream = file.OpenReadStream();
        var headerBytes = new byte[8];
        stream.Read(headerBytes, 0, headerBytes.Length);

        return FileSignatures[extension].Any(signature =>
            headerBytes.Take(signature.Length).SequenceEqual(signature));
    }
}
```

---

#### Acceptance Criteria

- [ ] File size limits enforced
- [ ] File type whitelist implemented
- [ ] MIME type validation added
- [ ] Filename sanitization implemented
- [ ] Magic byte validation added
- [ ] Path traversal prevented
- [ ] Files stored with random names
- [ ] Malware scanning considered (if budget allows)

---

### M-002: Update Angular Packages

**Finding ID:** M-002
**Severity:** MEDIUM
**Effort:** 1 hour
**Owner:** Frontend Team

---

#### Remediation Steps

```bash
# Update Angular to latest patch version
npm update @angular/animations@20.3.12
npm update @angular/common@20.3.12
npm update @angular/core@20.3.12
npm update @angular/forms@20.3.12
npm update @angular/platform-browser@20.3.12
npm update @angular/router@20.3.12
npm update @angular/service-worker@20.3.12
npm update @angular/compiler@20.3.12
npm update @angular/compiler-cli@20.3.12
npm update @angular/cli@20.3.10
npm update @angular/build@20.3.10

# OR use ng update
ng update @angular/core @angular/cli

# Test build
npm run build

# Test dev server
npm start

# Run tests
npm test
```

---

#### Acceptance Criteria

- [ ] All Angular packages updated to 20.3.12
- [ ] No breaking changes
- [ ] Application builds successfully
- [ ] All pages load correctly
- [ ] All tests pass
- [ ] No new console errors

---

### M-003: Implement Subresource Integrity (SRI)

**Finding ID:** M-003
**Severity:** MEDIUM
**Effort:** 6 hours
**Owner:** Frontend Team

---

#### Remediation Steps

**Step 1: Generate SRI Hashes (2 hours)**

```bash
# Install sri-toolbox
npm install --save-dev sri-toolbox

# Generate SRI hashes for external resources
sri-generate https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap
sri-generate https://fonts.googleapis.com/icon?family=Material+Icons
```

**Step 2: Update index.html (1 hour)**

```html
<!-- /workspaces/HRAPP/hrms-frontend/src/index.html -->

<link
  href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap"
  rel="stylesheet"
  integrity="sha384-..."  <!-- üëà ADD SRI HASH -->
  crossorigin="anonymous"
>

<link
  href="https://fonts.googleapis.com/icon?family=Material+Icons"
  rel="stylesheet"
  integrity="sha384-..."  <!-- üëà ADD SRI HASH -->
  crossorigin="anonymous"
>
```

**Step 3: Update Service Worker Config (3 hours)**

```json
// /workspaces/HRAPP/hrms-frontend/ngsw-config.json
{
  "assetGroups": [
    {
      "name": "app",
      "resources": {
        "files": [
          "/index.html",
          "/*.css",
          "/*.js"
        ],
        "urls": []  // Don't cache external resources without SRI
      }
    }
  ]
}
```

---

#### Acceptance Criteria

- [ ] SRI hashes generated for external resources
- [ ] index.html updated with integrity attributes
- [ ] crossorigin="anonymous" added
- [ ] Service worker doesn't cache external resources
- [ ] Fonts still load correctly
- [ ] No console errors

---

### M-004 - M-008: Quick Wins (2 hours each)

**See detailed remediation steps in SECURITY_HARDENING_CHECKLIST.md**

---

## PHASE 3: LOW PRIORITY FIXES

### L-001: Remove Production Console Logs

**Finding ID:** L-001
**Severity:** LOW
**Effort:** 2 hours
**Owner:** Frontend Team

---

#### Remediation Steps

**Step 1: Add Build-Time Log Stripping (1 hour)**

```json
// angular.json - production configuration
{
  "optimization": {
    "scripts": true,  // Already enabled
    "styles": { "minify": true },
    "fonts": true
  },
  "sourceMap": false  // ‚úÖ Disable source maps in production
}
```

**Step 2: Replace console.log with Logger Service (1 hour)**

```typescript
// Create logger service
@Injectable({ providedIn: 'root' })
export class LoggerService {
  private isDev = !environment.production;

  log(message: string, ...args: any[]): void {
    if (this.isDev) {
      console.log(message, ...args);
    }
  }

  error(message: string, ...args: any[]): void {
    if (this.isDev) {
      console.error(message, ...args);
    } else {
      // Send to error tracking service
      this.trackError(message, args);
    }
  }
}

// Usage:
// Replace: console.log('User logged in');
// With:    this.logger.log('User logged in');
```

---

### L-002 - L-005: Nice-to-Have Improvements

**See detailed remediation steps in SECURITY_HARDENING_CHECKLIST.md**

---

## TESTING STRATEGY

### Unit Testing

```bash
# Run unit tests after each fix
npm test

# Backend tests
dotnet test
```

---

### Integration Testing

```bash
# Test full login/logout flow
# Test token refresh flow
# Test file upload (M-001)
# Test security headers (H-001)
```

---

### Security Testing

```bash
# OWASP ZAP scan
zap-cli quick-scan http://localhost:4200

# Security Headers scan
curl -I https://your-domain.com | grep -E "Content-Security-Policy|X-Frame-Options|Strict-Transport-Security"

# NPM audit
npm audit

# .NET vulnerability scan
dotnet list package --vulnerable
```

---

### Manual Testing Checklist

- [ ] Login as SuperAdmin
- [ ] Login as Tenant Admin
- [ ] Login as Employee
- [ ] Logout from all roles
- [ ] Token refresh after 401
- [ ] Cross-tab logout
- [ ] File upload (if applicable)
- [ ] Real-time updates (SignalR)
- [ ] All dashboards load
- [ ] No console errors

---

## DEPLOYMENT STRATEGY

### Zero-Downtime Deployment

**Backend:**
```bash
# 1. Deploy security headers middleware
# 2. Test with canary deployment (5% traffic)
# 3. Monitor for errors
# 4. Roll out to 100%
```

**Frontend:**
```bash
# 1. Build production bundle
# 2. Upload to CDN
# 3. Update environment variables
# 4. Clear CDN cache
# 5. Monitor error rates
```

---

### Rollback Triggers

Rollback immediately if:
- Error rate > 1%
- Login failure rate > 5%
- CSP violations > 100/min
- SignalR connection failures > 10%

---

### Monitoring

**Metrics to Watch:**
- Login success rate
- Token refresh success rate
- API error rate
- CSP violation rate
- Page load time
- SignalR connection success rate

**Alerts:**
```bash
# Set up alerts for:
# - Error rate spike (> 1%)
# - Login failures (> 10/min)
# - CSP violations (> 50/min)
# - Security header missing
```

---

## SUCCESS CRITERIA

### Phase 1 Complete When:

- [ ] All High-priority findings resolved
- [ ] Security headers implemented and tested
- [ ] Refresh token removed from localStorage
- [ ] SuperAdmin secret rotated
- [ ] No production incidents
- [ ] Security Headers score: A or A+
- [ ] All tests passing

---

### Phase 2 Complete When:

- [ ] All Medium-priority findings resolved
- [ ] File upload security validated
- [ ] Angular packages updated
- [ ] SRI implemented for external resources
- [ ] No production incidents

---

### Phase 3 Complete When:

- [ ] All Low-priority findings resolved
- [ ] Production console logs removed
- [ ] Best practices implemented
- [ ] Documentation updated

---

## SIGN-OFF

### Phase 1 Approval

- [ ] Security Team Lead
- [ ] Backend Team Lead
- [ ] Frontend Team Lead
- [ ] DevOps Lead
- [ ] Product Owner

**Approved By:** ________________________ Date: ____________

---

### Phase 2 Approval

- [ ] Security Team Lead
- [ ] Backend Team Lead
- [ ] Frontend Team Lead

**Approved By:** ________________________ Date: ____________

---

### Phase 3 Approval

- [ ] Security Team Lead
- [ ] Frontend Team Lead

**Approved By:** ________________________ Date: ____________

---

## APPENDIX A: EMERGENCY CONTACTS

**Security Incidents:**
- Security Team Lead: security@morishr.com
- CTO: cto@morishr.com

**Technical Issues:**
- Backend Lead: backend@morishr.com
- Frontend Lead: frontend@morishr.com
- DevOps Lead: devops@morishr.com

---

## APPENDIX B: USEFUL COMMANDS

```bash
# Check security headers
curl -I https://your-domain.com

# NPM audit
npm audit
npm audit fix

# .NET vulnerability scan
dotnet list package --vulnerable

# OWASP ZAP scan
zap-cli quick-scan http://localhost:4200

# Security Headers online scan
https://securityheaders.com/?q=https://your-domain.com

# CSP validator
https://csp-evaluator.withgoogle.com/
```

---

**Document End**
Last Updated: 2025-11-17
Version: 1.0
Status: ACTIVE
