# Custom PostgreSQL Exporter Queries
# Optimized for multi-tenant SaaS monitoring
# Performance: <5ms query execution time

# ==============================================================================
# Multi-Tenant Schema Metrics
# ==============================================================================
pg_tenant_schemas:
  query: |
    SELECT
      nspname AS schema_name,
      pg_size_pretty(SUM(pg_total_relation_size(C.oid))) AS total_size_pretty,
      SUM(pg_total_relation_size(C.oid)) AS total_size_bytes,
      COUNT(DISTINCT C.relname) AS table_count
    FROM pg_class C
    LEFT JOIN pg_namespace N ON (N.oid = C.relnamespace)
    WHERE nspname LIKE 'tenant_%'
      AND C.relkind = 'r'
    GROUP BY nspname
    ORDER BY total_size_bytes DESC;
  metrics:
    - schema_name:
        usage: "LABEL"
        description: "Tenant schema name"
    - total_size_bytes:
        usage: "GAUGE"
        description: "Total size of tenant schema in bytes"
    - table_count:
        usage: "GAUGE"
        description: "Number of tables in tenant schema"

# ==============================================================================
# Connection Pool Statistics
# ==============================================================================
pg_connection_pool_stats:
  query: |
    SELECT
      state,
      COUNT(*) as connections,
      MAX(EXTRACT(EPOCH FROM (NOW() - state_change))) as max_idle_seconds
    FROM pg_stat_activity
    WHERE pid != pg_backend_pid()
    GROUP BY state;
  metrics:
    - state:
        usage: "LABEL"
        description: "Connection state"
    - connections:
        usage: "GAUGE"
        description: "Number of connections in this state"
    - max_idle_seconds:
        usage: "GAUGE"
        description: "Maximum idle time for this state"

# ==============================================================================
# Slow Query Detection (>100ms)
# ==============================================================================
pg_slow_queries:
  query: |
    SELECT
      COUNT(*) FILTER (WHERE mean_exec_time > 100) as slow_queries_100ms,
      COUNT(*) FILTER (WHERE mean_exec_time > 500) as slow_queries_500ms,
      COUNT(*) FILTER (WHERE mean_exec_time > 1000) as slow_queries_1s
    FROM pg_stat_statements
    WHERE queryid IS NOT NULL;
  metrics:
    - slow_queries_100ms:
        usage: "GAUGE"
        description: "Queries slower than 100ms"
    - slow_queries_500ms:
        usage: "GAUGE"
        description: "Queries slower than 500ms"
    - slow_queries_1s:
        usage: "GAUGE"
        description: "Queries slower than 1 second"

# ==============================================================================
# Index Usage Statistics (detect unused indexes)
# ==============================================================================
pg_index_usage:
  query: |
    SELECT
      schemaname,
      tablename,
      indexname,
      idx_scan as scans,
      idx_tup_read as tuples_read,
      idx_tup_fetch as tuples_fetched,
      pg_size_pretty(pg_relation_size(indexrelid)) as index_size
    FROM pg_stat_user_indexes
    WHERE schemaname NOT LIKE 'pg_%'
      AND idx_scan < 100
      AND pg_relation_size(indexrelid) > 1048576  -- >1MB
    ORDER BY pg_relation_size(indexrelid) DESC
    LIMIT 20;
  metrics:
    - schemaname:
        usage: "LABEL"
        description: "Schema name"
    - tablename:
        usage: "LABEL"
        description: "Table name"
    - indexname:
        usage: "LABEL"
        description: "Index name"
    - scans:
        usage: "COUNTER"
        description: "Number of index scans"
    - tuples_read:
        usage: "COUNTER"
        description: "Tuples read from index"

# ==============================================================================
# Table Bloat Detection
# ==============================================================================
pg_table_bloat:
  query: |
    SELECT
      schemaname,
      tablename,
      pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as total_size,
      n_dead_tup as dead_tuples,
      ROUND(100 * n_dead_tup / NULLIF(n_live_tup + n_dead_tup, 0), 2) as bloat_ratio
    FROM pg_stat_user_tables
    WHERE n_dead_tup > 1000
      AND schemaname NOT LIKE 'pg_%'
    ORDER BY n_dead_tup DESC
    LIMIT 20;
  metrics:
    - schemaname:
        usage: "LABEL"
        description: "Schema name"
    - tablename:
        usage: "LABEL"
        description: "Table name"
    - dead_tuples:
        usage: "GAUGE"
        description: "Number of dead tuples"
    - bloat_ratio:
        usage: "GAUGE"
        description: "Percentage of dead tuples"

# ==============================================================================
# Replication Lag (if using read replicas)
# ==============================================================================
pg_replication_lag:
  query: |
    SELECT
      COALESCE(EXTRACT(EPOCH FROM (NOW() - pg_last_xact_replay_timestamp())), 0) AS lag_seconds
    WHERE pg_is_in_recovery();
  metrics:
    - lag_seconds:
        usage: "GAUGE"
        description: "Replication lag in seconds"

# ==============================================================================
# Lock Contention
# ==============================================================================
pg_locks_detail:
  query: |
    SELECT
      locktype,
      mode,
      COUNT(*) as lock_count
    FROM pg_locks
    WHERE NOT granted
    GROUP BY locktype, mode;
  metrics:
    - locktype:
        usage: "LABEL"
        description: "Type of lock"
    - mode:
        usage: "LABEL"
        description: "Lock mode"
    - lock_count:
        usage: "GAUGE"
        description: "Number of locks"
